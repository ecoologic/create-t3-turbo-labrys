name: Sync Upstream

# This workflow syncs changes from t3-oss/create-t3-turbo upstream repository.
# When merge conflicts occur:
# - If ONLY pnpm-lock.yaml conflicts: automatically resolve by accepting upstream's
#   lockfile and running 'pnpm install', then create PR with notice
# - If other files conflict: abort merge and create issue for manual resolution
#
# Auto-merge is enabled on created PRs to automatically merge them once CI checks pass.
# This workflow uses a SYNC_TOKEN (Personal Access Token) to create PRs, and GITHUB_TOKEN
# (github-actions[bot]) to auto-approve them - satisfying the required reviews rule.
#
# Setup required:
# 1. Create a Personal Access Token (classic) with 'repo' scope
# 2. Add the PAT as a repository secret named 'SYNC_TOKEN'
# 3. The workflow will:
#    - Create PR using SYNC_TOKEN (your user identity)
#    - Auto-approve using GITHUB_TOKEN (github-actions[bot] - different identity)
#    - Enable auto-merge to merge once CI passes

on:
  # https://github.com/Labrys-Group/create-t3-turbo/actions/workflows/sync-upstream.yml
  # Click "Run workflow"
  workflow_dispatch: # Allow manual triggering

jobs:
  sync:
    # Only run this workflow in the original repository, not in repos created from template
    if: github.repository == 'Labrys-Group/create-t3-turbo'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          # Use SYNC_TOKEN if available (PAT with admin rights to bypass protections)
          # Otherwise fall back to GITHUB_TOKEN (respects branch protections)
          token: ${{ secrets.SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/t3-oss/create-t3-turbo.git || true
          git fetch upstream

      - name: Check for upstream changes
        id: check
        run: |
          # Get the latest commit from upstream main
          UPSTREAM_COMMIT=$(git rev-parse upstream/main)
          # Check if we have this commit locally
          if git merge-base --is-ancestor "$UPSTREAM_COMMIT" HEAD; then
            echo "already_synced=true" >> "$GITHUB_OUTPUT"
            echo "No new changes from upstream"
          else
            echo "already_synced=false" >> "$GITHUB_OUTPUT"
            echo "New changes detected from upstream"

            # Get the list of new commits from upstream
            MERGE_BASE=$(git merge-base HEAD upstream/main)
            COMMITS=$(git log --pretty=format:"- %s ([%h](https://github.com/t3-oss/create-t3-turbo/commit/%H)) by %an" $MERGE_BASE..upstream/main)

            # Store commits in output (handle multiline)
            echo "new_commits<<EOF" >> $GITHUB_OUTPUT
            echo "$COMMITS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Create sync branch and merge upstream
        if: steps.check.outputs.already_synced == 'false'
        id: merge
        run: |
          # Create a new branch for the sync
          BRANCH_NAME="sync-upstream-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> "$GITHUB_ENV"

          # Attempt to merge upstream changes
          if git merge upstream/main --no-edit --allow-unrelated-histories; then
            echo "Merge successful"
            echo "merge_status=success" >> "$GITHUB_OUTPUT"
            # Push the branch
            git push origin "$BRANCH_NAME"
          else
            echo "Merge conflict detected"
            echo "merge_status=conflict" >> "$GITHUB_OUTPUT"
            # Don't abort - let analyze step handle conflicts
          fi

      - name: Analyze conflicts
        if: steps.check.outputs.already_synced == 'false' && steps.merge.outputs.merge_status == 'conflict'
        id: analyze
        run: |
          # Get list of conflicted files
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)

          # Check if ONLY pnpm-lock.yaml conflicts
          if [ "$CONFLICTED_FILES" = "pnpm-lock.yaml" ]; then
            echo "only_lockfile=true" >> "$GITHUB_OUTPUT"
            echo "Only pnpm-lock.yaml conflicts detected - will auto-resolve"
          else
            echo "only_lockfile=false" >> "$GITHUB_OUTPUT"
            echo "Multiple files conflict - manual resolution required"
          fi

          # Store conflicted files for issue creation
          {
            echo "conflicted_files<<EOF"
            echo "$CONFLICTED_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          # Abort merge if not auto-resolving
          if [ "$CONFLICTED_FILES" != "pnpm-lock.yaml" ]; then
            git merge --abort
          fi

      - name: Setup Node.js
        if: steps.check.outputs.already_synced == 'false' && steps.analyze.outputs.only_lockfile == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        if: steps.check.outputs.already_synced == 'false' && steps.analyze.outputs.only_lockfile == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: 10.19.0
          run_install: false

      - name: Auto-resolve lockfile conflict
        if: steps.check.outputs.already_synced == 'false' && steps.analyze.outputs.only_lockfile == 'true'
        id: auto_resolve
        run: |
          echo "Auto-resolving pnpm-lock.yaml conflict..."

          # Accept upstream's lockfile (preserves their dependency resolutions)
          git checkout --theirs pnpm-lock.yaml

          # Update lockfile based on merged package.json
          if ! pnpm install --no-frozen-lockfile; then
            echo "pnpm install failed - aborting merge"
            echo "resolution_status=failed" >> "$GITHUB_OUTPUT"
            git merge --abort
            exit 1
          fi

          # Stage the updated lockfile
          git add pnpm-lock.yaml

          # Complete the merge commit
          git commit --no-edit

          # Push the branch
          git push origin "${{ env.branch_name }}"

          echo "resolution_status=success" >> "$GITHUB_OUTPUT"
          echo "Lockfile conflict auto-resolved successfully"

      - name: Create Pull Request
        if: steps.check.outputs.already_synced == 'false' && (steps.merge.outputs.merge_status == 'success' || (steps.analyze.outputs.only_lockfile == 'true' && steps.auto_resolve.outputs.resolution_status == 'success'))
        uses: actions/github-script@v7
        env:
          # Pass GITHUB_TOKEN separately for auto-approval (different identity from PR creator)
          APPROVAL_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Use SYNC_TOKEN if available (PAT with admin rights to bypass protections)
          # Otherwise fall back to GITHUB_TOKEN (respects branch protections)
          github-token: ${{ secrets.SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const branchName = process.env.branch_name;

            const newCommits = process.env['new_commits'] || '';

            // Check if lockfile was auto-resolved
            const autoResolved = '${{ steps.analyze.outputs.only_lockfile }}' === 'true' && '${{ steps.auto_resolve.outputs.resolution_status }}' === 'success';

            // Build the PR body with new commits
            let prBody = 'This PR syncs changes from the upstream repository [t3-oss/create-t3-turbo](https://github.com/t3-oss/create-t3-turbo).\n\n';

            if (newCommits && newCommits.trim()) {
              prBody += '## New Commits from Upstream\n\n';
              prBody += newCommits + '\n\n';
            }

            // Add auto-resolution notice if applicable
            if (autoResolved) {
              prBody += '## ‚ö†Ô∏è Auto-Resolution Notice\n\nThe pnpm-lock.yaml file had merge conflicts and was automatically resolved by accepting upstream\'s lockfile and running `pnpm install`.\nPlease verify the lockfile changes are correct before merging.\n\n';
            }

            prBody += '## Auto-Merge Enabled ‚ú®\n\n';
            prBody += 'This PR has **auto-merge** enabled and will be automatically merged once all required CI checks pass.\n\n';
            prBody += '**Note:** This workflow uses a PAT with admin privileges to bypass review requirements.\n\n';
            prBody += '## Review Notes\n';
            prBody += '- Auto-merge will wait for all required status checks to complete\n';
            prBody += '- Review requirements are bypassed via admin token\n';
            prBody += '- If you need to review changes manually, you can disable auto-merge on this PR\n';
            prBody += '- Check for any conflicts with custom modifications in this fork\n\n';
            prBody += '---\n';
            prBody += 'ü§ñ This PR was automatically created by the sync-upstream workflow.';

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Sync with upstream t3-oss/create-t3-turbo',
                head: branchName,
                base: 'main',
                body: prBody,
              });

              console.log(`Pull request created: ${pr.html_url}`);

              // Auto-approve the PR using GITHUB_TOKEN (different identity from PR creator)
              // This satisfies the "required reviews" branch protection rule
              const hasSyncToken = '${{ secrets.SYNC_TOKEN }}' !== '';
              if (hasSyncToken && process.env.APPROVAL_TOKEN) {
                try {
                  const { getOctokit } = require('@actions/github');
                  const approvalOctokit = getOctokit(process.env.APPROVAL_TOKEN);

                  await approvalOctokit.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    event: 'APPROVE',
                    body: 'ü§ñ Auto-approved by sync workflow (CI checks still required)'
                  });
                  console.log(`PR #${pr.number} auto-approved using GITHUB_TOKEN`);
                } catch (approvalError) {
                  console.log('Auto-approval failed:', approvalError.message);
                  console.log('The PR may still require manual approval.');
                }
              }

              // Enable auto-merge for the PR
              try {
                await github.rest.pulls.updateBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                });
                console.log('Updated branch with base branch');
              } catch (updateError) {
                console.log('Branch update not needed or failed:', updateError.message);
              }

              // Enable auto-merge using GraphQL API
              try {
                const prNodeId = pr.node_id;
                
                // Check if we're using SYNC_TOKEN (admin token that can bypass protections)
                const hasAdminToken = '${{ secrets.SYNC_TOKEN }}' !== '';
                
                const mutation = `
                  mutation EnableAutoMerge($pullRequestId: ID!) {
                    enablePullRequestAutoMerge(input: {
                      pullRequestId: $pullRequestId,
                      mergeMethod: SQUASH
                    }) {
                      pullRequest {
                        autoMergeRequest {
                          enabledAt
                        }
                      }
                    }
                  }
                `;

                await github.graphql(mutation, {
                  pullRequestId: prNodeId,
                });

                console.log(`Auto-merge enabled for PR #${pr.number}`);
                
                if (hasAdminToken) {
                  console.log('‚úì Using SYNC_TOKEN with admin privileges - will bypass review requirements');
                  console.log('‚úì The PR will be automatically merged once CI checks pass');
                } else {
                  console.log('‚ö† Using GITHUB_TOKEN - will wait for required reviews and checks');
                  console.log('‚ö† To bypass review requirements, set up a SYNC_TOKEN secret with admin privileges');
                  console.log('  See README.md for setup instructions');
                }
              } catch (autoMergeError) {
                console.error('Failed to enable auto-merge:', autoMergeError.message);
                console.log('The PR was created but auto-merge could not be enabled.');
                console.log('You may need to enable it manually or check repository settings.');
              }
            } catch (error) {
              if (error.status === 422) {
                console.log('Pull request already exists or no changes to sync');
              } else {
                throw error;
              }
            }

      - name: Create Issue for Merge Conflict
        if: steps.check.outputs.already_synced == 'false' && steps.merge.outputs.merge_status == 'conflict' && steps.analyze.outputs.only_lockfile == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = process.env.branch_name;
            const conflictedFiles = `${{ steps.analyze.outputs.conflicted_files }}`;

            const issueBody = `## üîÑ Upstream Sync Failed - Merge Conflict

            The automated sync from [t3-oss/create-t3-turbo](https://github.com/t3-oss/create-t3-turbo) failed due to merge conflicts.

            ### Conflicted Files
            \`\`\`
            ${conflictedFiles}
            \`\`\`

            ### What to do
            1. Manually sync the upstream changes:
               \`\`\`bash
               git fetch upstream
               git checkout -b ${branchName}
               git merge upstream/main
               \`\`\`
            2. Resolve the conflicts in the files listed above
            3. Commit the resolved changes:
               \`\`\`bash
               git add .
               git commit -m "Resolve merge conflicts from upstream sync"
               \`\`\`
            4. Push and create a PR:
               \`\`\`bash
               git push origin ${branchName}
               \`\`\`

            ### Additional Information
            - **Workflow Run**: [${context.runId}](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            - **Attempted Branch**: \`${branchName}\`

            ---
            ü§ñ This issue was automatically created by the sync-upstream workflow.`;

            try {
              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Upstream sync failed: Merge conflict in branch ${branchName}`,
                body: issueBody,
                labels: ['upstream-sync', 'merge-conflict']
              });

              console.log(`Issue created: ${issue.html_url}`);
            } catch (error) {
              console.error('Failed to create issue:', error);
              throw error;
            }
